# RoutAI

## Usage

To run this application create a .env file and enter the required API keys.

```bash
cp .env.example .env
```

Then ensure Docker is running and simply run:

```bash
docker compose up
```

## Overview

### Agentic Workflow

I used LangGraph to build the backend AI system. My main requirements were:

 - Route Optimisation: Once a route has been create the system should be able to update it based on user requests.
 - Real Data Fetching: Ensure that route information is provide by tools rather than generated by the AI.

To tackle this I created a graph of 4 steps.

#### Planning

 The agent's sole purpose is to convert an unstructured user query into a validated RouteRequirements Pydantic object. If the object fails validation (e.g., missing start/end points), the agent is instructed to query the user for the missing details, this prevents the possible errors in the route calculation.

#### Route Creation

 This node is purely computational. It takes the validated RouteRequirements and uses external routing tools (not the LLM) to calculate the initial route, segment it by daily distance, and fetch initial accommodation options. It guarantees that the core route data is derived from authoritative tools. It avoids the nightmare scenario of a user cycling 100km to a hotel or city in the middle of Nepal that doesnt actually exist.

#### Optimisation

This agent is tasked with modifying existing itinerary data based on follow-up user requests ("Make the next day shorter," "Find a hotel closer to the coast"). It uses powerful tools to directly update the RouteState (e.g., recalculate_segment), allowing for dynamic, contextual changes without restarting the planning process.

#### Review

The final stage summarises the current RouteState for the user. It has access to tools like get_weather to add more information to the final output.

### Tech Choices

 - **LangGraph:** I opted for LangGraph so I could build the multi stage approach with a global state. It allows for iteration, conditional logic, and the persistent tracking of complex data which a simple LangChain Agent would struggle with this, often ending up in tool-use loops or forgetting previous context. The global state for a workflow is allows accessible at any time and identifed using a thread_id, this allows accesing route data without interacting with the Workflow.

    - __Stateful Persistence__: The global state (AgentState) ensures all generated data (coordinates, routes, segment definitions) is accessible to any node in the graph, eliminating the need to pass large, complex objects between stateless API calls. The state is also accebilbe outside of the workflow meaning we can query the state and just retrieve the final route to, for example, plot for the user.

    - __Conditional Execution__: Using a graph allows for non-linear routing (e.g., If insufficient requirements are met, Then route to Planning; Else route to Creation).

    - __Determinism__: By isolating the heavy lifting, like route calculation, into dedicated, deterministic, non-agentic nodes, we can almost gaurantee a realistic route will be generated. There's no concern of an llm hallucinating a location.

 - **Pydantic** Perfect for type validation and a number of AI models support structured output defined by Pydantic.

### Repositry Architecture

```
backend/
├── app/
│   ├── main.py                  # Application entry point
│   │
│   ├── api/                     # FastAPI application layer
│   │   ├── deps.py              # Dependency injection
│   │   ├── routes/              # API endpoints
│   │   │   ├── chats.py         # Chat streaming endpoints
│   │   │   └── sessions.py      # Session management endpoints
│   │   │   
│   │   └── services/            
│   │       ├── session_manager.py  # Session state management
│   │       └── streaming.py        # SSE streaming logic
│   │
│   ├── agent/                   # LangGraph agent implementation
│   │   ├── config/               
│   │   │   ├── llm.py           # Claude LLM setup
│   │   │   └── prompts.py       # System prompts for each agent
│   │   │ 
│   │   ├── graph/               
│   │   │   ├── routing.py       # Conditional routing logic
│   │   │   └── workflow.py      # Main LangGraph workflow definition
│   │   │
│   │   └── nodes/                
│   │       ├── logistics.py     # Accommodation search node
│   │       ├── optimiser.py     # Route optimization node
│   │       ├── planner.py       # Requirements gathering node
│   │       ├── reviewer.py      # Route review and confirmation node
│   │       ├── router.py        # Route calculation node
│   │       └── writer.py        # Itinerary generation node
│   │ 
│   ├── models/                  # Pydantic data models
│   │   ├── api.py               # API request/response models
│   │   ├── models.py            # Core domain models
│   │   └── state.py             # Agent state models
│   │
│   ├── tools/                   # LangChain tools for agents
│   │   ├── accommodation.py     # Accommodation search tools
│   │   ├── location.py          # Geocoding tools
│   │   ├── route.py             # Route manipulation tools
│   │   ├── segment.py           # Segment inspection tools
│   │   ├── utils.py             # Tool utilities
│   │   └── weather.py           # Weather information tools
│   │
│   ├── utils/                   # Shared utilities
│   │   └── utils.py             # Google API integrations, calculations
│   │
│   ├── config/                  # Application configuration
│   │   ├── config.py            # Settings and environment variables
│   │   └── logging.py           # Logging configuration
│   │
├── scripts/                     # Development and utility scripts
├── tests/                       # Test suite
└── pyproject.toml               # Project dependencies (uv)
 ```

The repository follows a clean, layered architecture to promote maintainability, testability, and clear separation of concerns:

 - Application Layer (api/): Handles HTTP requests (FastAPI), authentication, and streaming logic. It is solely concerned with I/O and routing.

 - Domain/Agent Layer (agent/): Contains the core business logic (the LangGraph workflow). This layer is decoupled from the API and defines the structure and behavior of the agents and their state transitions.

 - Data Models (models/): Holds all data contracts (Pydantic models) centralizing the definition of the RouteState, API contracts, and domain entities.

 - Tool/Utility Layer (tools/, utils/): Provides the necessary integration and computational resources. Agents call these tools, but the tools themselves are not agentic, ensuring deterministic calculations are isolated.

This structure allows the entire agent/ workflow to be tested independently of the HTTP layer, simplifying development and ensuring the core logic remains stable.

## Further Development

If given more time, the key areas for development would be:

 - __Robustness__: Improving error handling across all nodes and implementing more comprehensive logging. Agentic systems are difficult to debug without detailed logging for each tool call and state transition.
 
 - __Smarter Route Optimization:__ Giving the Optimization agent more powerful tools to vary segment lengths based on difficulty (using get_elevation_profile) or dynamically move waypoints to better match Points of Interest.

 - __Enriched Content:__  Implementing the get_points_of_interest tool and giving the Review agent the ability to check for blog posts or user-generated content for a route to suggest meaningful, local changes or highlights.

 - __UI Integration:__ Allowing the user to update the route in a GUI, with the action then updating the LangGraph's state to trigger a new overview generation.
